# JS对象中是否存在循环引用

## 什么情况下会出现循环引用

```javascript
function circularReference() {
  let obj1 = {};
	let obj2 = {
 	 		b: obj1
		};
	obj1.a = obj2;
}
```

上述例子中的情况 对象obj1中的a属性引用了obj2，而obj2中的b属性引用了obj1.
![image-20220715135213858](https://cdn.jsdelivr.net/gh/hjc0826/map-depot@main/uPic/2022-07-15 13:52:14 image-20220715135213858.png)

上述示意图可以清楚的看出两个对象出现了内存地址的循环引用

## JS中引用计数垃圾回收策略的问题

在js垃圾回收机制中有一个引用计数的回收策略，当一个变量被赋予一个引用类型的值时，这个引用类型的值的引用计数器就会+1.就像以上obj1这个**变量**被赋予了obj1这个对象的地址，obj1这个变量就**指向**了这个obj1这个对象，obj1的引用计数就会+1，当变量obj1的值不再是obj1这个对象的地址时，（比如delete 或者 手动改变）obj1这个对象的引用计数就会-1，当这个obj1对象引用计数变为0后，垃圾收集器就会将其回收，因为此时没有变量指向它，也没没办法使用。

### 引用计数回收策略会有什么问题

就上面所说的循环引用所导致的，分析一下。当obj1这个变量引用了obj1这个对象时，此时obj1的引用计数就会+1，接下来obj2的b属性有志向了这个obj1对象，所以此时obj1这个对象的引用计数为2.同理obj2也是。

当代码执行完毕之后，会将变量obj1和obj2赋值为null（**一般来说，当函数执行完毕后，局部活动对象就会被销毁**），但是此时obj1和obj2因为存在互相引用，所以引用计数都为1，并不为0，所以回收器并不会将其回收，但是这两个对象已经没用了，从而造成了内存泄漏。

引用计数是老一代内核会采取的回收机制，目前广泛采用的**标记回收策略**就不会出现以上那种问题，大概流程为：最开始的时候将所有变量加上标记，当执行cycularReference函数的时候会将函数内部的变量这些标记清除，在函数执行完毕之后在加上标记。这些被清除标记标记的变量就被视为将要被清除的变量，原因是这些函数中的变量已经无法被访问到了。无需关注对象引用的次数。

## 循环引用的对象使用JSON.stringify为什么会报错

*JSON.stringify* 用于将一个JS对象序列化为一个JSON字符串，假设现在我们将obj1这个对象序列化为JSON字符串。

```javascript
function circularReference() {
  let obj1 = {};
	let obj2 = {
 	 		b: obj1
		};
	obj1.a = obj2;
  console.log(obj1)
}
circularReference()
```

![image-20220715141707281](https://cdn.jsdelivr.net/gh/hjc0826/map-depot@main/uPic/2022-07-15 14:17:07 image-20220715141707281.png)

obj1 这个对象和obj2 会无限相互引用，JSON.stringify 无法将一个无限引用的对象序列化为JSON字符串。

下面为MDN的解释

![image-20220715141947539](https://cdn.jsdelivr.net/gh/hjc0826/map-depot@main/uPic/2022-07-15 14:19:47 image-20220715141947539.png)

### 解决方法

存在一个JSON扩展包可以去重循环引用，使用 [JSON.decycle](https://www.npmjs.com/package/json-decycle)

```javascript
function circularReference() {
  let obj1 = {
  };
  let obj2 = {
    b: obj1
  };
  obj1.a = obj2;
  let c = JSON.decycle(obj1);
  console.log(JSON.stringify(c));
}
circularReference();
```



## 判断对象是否存在循环引用

```javascript
function cycle(obj, parent) {
  let parentArr = parent || [obj]
  for (var i in obj) {
    if (typeof obj[i] === "object") {
      //判断是否有循环引用
      parentArr.forEach((pObj) => {
        if (pObj === obj[i]) {
          obj[i] = "[cycle]"
        }
      });
      cycle(obj[i], [...parentArr, obj[i]])
    }
  }
  return obj
}
```


# Typescript

# 一、Typescript与JavaScript的区别，在项目中使用Typescript的优点

#### 1.区别

TypeScript 中的数据要求带有明确的类型（就算没有定义类型，也会有类型推断），JavaScript不要求。

TypeScript 通过类型注解(就是人为的为一个变量指定类型)提供编译时的静态类型检查。

#### 2.优点

JavaScript 代码可以在无需任何修改的情况下与 TypeScript 一同工作，能够使项目很好的向TypeScript过渡，同时可以使用编译器将 TypeScript 代码转换为 JavaScript。

可以在编译阶段就发现大部分错误。

# 二、基础类型

除继承了JavaScript的类型（布尔值、数字、字符串、数组、Null、Undefined、Object）外，还新增了一些类型

#### 1.任意类型 any

变量的类型是动态的，可以是任意的，并且不会被类型检查器而检查，可以顺利通过编译阶段

```typescript
let dynamic: any = 4;
dynamic = "daphnisli";

```

#### 2.无任何类型void

变量没有任何类型，函数没有返回值的时候也可以定义函数为void类型

```typescript
function notReturned(): void {
    console.log("daphnisli");
}

```

声明一个void类型的变量没有什么大用，因为只能为它赋予undefined和null：

```typescript
let notReturned: void = undefined;

```

#### 3.元组 Tuple

元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同，但是要注意类型的顺序。 比如，下面定义一对值分别为 string和number类型的元组。

```typescript
let x: [string, number];
x = ['hello', 10]; // OK
x = [10, 'hello']; // Error

```

#### 4.Never

never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；

```typescript
function error(message: string): never {
    throw new Error(message);
}

```

#### 5.枚举

下面定义了一个数字枚举， Up初始化为 1。 其余的成员会从 1开始自动增长。还可以不使用初始化，那么UP为0

```typescript
enum Enumerate {
    Up = 1,
    Down,
    Left,
    Right
}

```

而在一个字符串枚举里，每个成员都必须用字符串，或用另外一个字符串枚举成员进行初始化。

```typescript
enum Enumerate {
    Up = "UP",
    Down = "DOWN",
    Left = "LEFT",
    Right = "RIGHT",
}

```

#### 6.类型断言（类型转换）

有时候会遇到这样的情况，我会比TypeScript更了解某个变量的详细信息。 通过类型断言这种方式可以告诉编译器，“我知道这个变量的类型”。它没有运行时的影响，只是在编译阶段起作用。

尖括号

```typescript
let str: any = "daphnisli";
let strLength: number = (<string>str).length;

```

react只支持as语法

```typescript
let str: any = "this is a string";
let strLength: number = (str as string).length;

```

# 三、接口

接口是对变量类型的一种描述，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。

```typescript
interface LabelledValue {
  ordinary: string // 普通属性
  optional?: string	// 可选属性
  readonly readOnly: number // 只读属性
}


```

***类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。***

# 四、函数

***对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配，函数的参数会逐个进行检查并要求对应位置上的参数类型是相同的。***

***TypeScript里的每个函数参数都是必须的。传递给一个函数的参数个数必须与函数期望的参数个数一致。（不一致会报错）***

#### 1.可选参数和默认参数

***在TypeScript里可以在参数名旁使用 ?实现可选参数的功能***

```typescript
function buildName(firstName: string, lastName?: string) {
    if (lastName)
        return firstName + " " + lastName;
    else
        return firstName;
}
let result1 = buildName("Bob");  // works correctly now
let result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
let result3 = buildName("Bob", "Adams");  // ah, just right

```

***在TypeScript里，可以为参数提供一个默认值，当没有传递这个参数或传递的值是undefined时，这个参数就有默认的初始值。***

***带默认初始化的参数都是可选类型的，与可选参数一样，在调用函数的时候可以省略。***

```typescript
function buildName(firstName: string, lastName = "Smith") {
    return firstName + " " + lastName;
}
let result1 = buildName("Bob");                  // works correctly now, returns "Bob Smith"
let result2 = buildName("Bob", undefined);       // still works, also returns "Bob Smith"
let result3 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
let result4 = buildName("Bob", "Adams");         // ah, just right

```

***注意：可选参数一定要放在必须参数的后面(原因：因为参数是按照顺序去检查类型的，所以这样做是为了保证参数的顺序), 默认参数可以放在必需参数前面，但是为了保证参数的顺序，一定要传入undefined来获取默认值***

#### 2.剩余参数(同arguments)

***必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，想同时操作多个参数，或者并不知道会有多少参数传递进来。 在JavaScript里，可以使用 arguments来访问所有传入的参数。在TypeScript里，可以把所有参数收集到一个变量里：***

```typescript
function buildName(firstName: string, ...restOfName: string[]) {
  return firstName + " " + restOfName.join(" ");
}
let employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie");
//Joseph Samuel Lucas MacKinzie

```

# 五、泛型

作用：创建可重用的组件，一个组件可以支持多种类型的数据

#### 1.初识泛型

比如：generic函数的功能是要返回传入的参数arg，如果不使用泛型，那么是这样的

```typescript
function generic(arg: any): any {
		// 进行一些操作～～～
    return arg;
}

```

使用any类型会导致这个函数可以接收任何类型的arg参数，***这样就会导致一个错误：传入的类型与返回的类型应该是相同的，但是如果用any就会导致不知道返回什么类型的值。

***因此就需要一种方法使返回值的类型与传入参数的类型是相同的。那就是泛型（泛型代表任何类型）***

```typescript
function generic<T>(arg: T): T {
    return arg;
}
定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：
let output = generic<string>("myString");  
这里明确的指定了T是string类型，并做为一个参数传给函数

第二种，利用了类型推论 -- 编译器会根据传入的参数自动地帮助我们确定T的类型：
let output = generic("myString"); 

注意我们没必要使用尖括号（<>）来明确地传入类型；编译器可以查看myString的值，然后把T设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。

#####更推荐第一种用法

```

***T帮助我们捕获用户传入的类型（比如：string）， 当再次使用了 T当做返回值类型。现在就可以知道参数类型与返回值类型是相同的了。***

#### 2.使用泛型

再举个例子，如果想同时打印出arg的长度。 很可能会这样做：

```typescript
function genericLength<T>(arg: T): T {
    console.log(arg.length); 
    return arg;
}

```

这么做编辑器会报错，因为arg是任意类型，它不一定具有length属性，万一T是number,那就没有length属性，但是数组就有length属性。

所以为了避免出现以上错误，我们可以在arg后面指定，arg是T类型中的数组类型

```typescript
function genericLength<T>(arg: Array<T>): Array<T> {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}

```

这样做可以让我们把泛型变量T当做T类型的一部分使用，而不是整个类型，增加了灵活性。

***如果想用接口来描述我们想用T类型中的数组类型,该怎么办？***

可以使用extends关键字进行约束

```typescript
interface Lengthwise {
    length: number;
}
function genericLength<T extends Lengthwise>(arg: T): T {
    console.log(arg.length); 
    return arg;
}

```

***注意：现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：***

```typescript
genericLength(3);  // 报错，number没有length属性
我们需要传入符合约束类型的值，必须包含必须的属性：
genericLength({length: 10, value: 3});

```

# 六、类型推论

#### 1.基础

TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子

```typescript
let x = 3;

```

变量x的类型被推断为数字。 ***这种推断发生在初始化变量、设置默认参数值和决定函数返回值时。***

#### 2.最佳通用类型

当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。例如下面的例子

```typescript
let x = [0, 1, null];

```

为了推断x的类型，必须考虑所有元素的类型。 这里有两种选择： number和null。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。

由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。例如下面的例子

```typescript
let zoo = [new Cat(), new Dog(), new Mouse()];

```

这里，我们想让zoo被推断为Animal[]类型，但是这个数组里没有对象是Animal类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：

```typescript
let zoo: Animal[] = [new Cat(), new Dog(), new Mouse()];

```

如果未明确指出类型并且没有找到最佳通用类型的话，类型推断的结果为联合数组类型，(Cat | Dog | Mouse)[]。

#### 3.上下文类型

TypeScript类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。比如下面的例子

```typescript
window.onmousedown = function(mouseEvent) {
    console.log(mouseEvent.button);  //<- Error
};

```

这个例子会得到一个类型错误，TypeScript类型检查器使用Window.onmousedown函数的类型来推断右边函数表达式的类型。 因此，就能推断出 mouseEvent参数的类型了。 如果函数表达式不是在上下文类型的位置， mouseEvent参数的类型需要指定为any，这样也不会报错了。

如果上下文类型表达式包含了明确的类型信息，上下文的类型就会被忽略。重写一下上面的例子：

```typescript
window.onmousedown = function(mouseEvent: any) {
    console.log(mouseEvent.button);  
};

```

这个函数表达式有明确的参数类型注解，上下文类型被忽略。 这样的话就不报错了，因为这里不会使用到上下文类型。

上下文归类会在很多情况下使用到。 通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。 上下文类型也会做为最佳通用类型的候选类型。比如：

```typescript
function createZoo(): Animal[] {
    return [new Cat(), new Dog(), new Mouse()];
}

```

这个例子里，最佳通用类型有4个候选者：Animal，Cat，Dog和Mouse。 当然， Animal会被做为最佳通用类型。

# 七、类型兼容性

#### 1.开始

TypeScript结构化类型系统的基本规则是：***如果x要兼容y，那么y至少具有与x相同的属性。比如：***

```typescript
interface Named {
    name: string;
}

let x: Named;
// y's inferred type is { name: string; location: string; }
let y = { name: 'Alice', location: 'Seattle' };
x = y;

```

这里要检查y是否能赋值给x，编译器检查x中的每个属性，看是否能在y中也找到对应属性。 在这个例子中，y必须包含名字是name的string类型成员。y满足条件，因此赋值正确。

***检查函数参数时使用相同的规则：***

```typescript
function greet(n: Named) {
    console.log('Hello, ' + n.name);
}
greet(y); // OK

```

注意，y有个额外的location属性，但这不会引发错误（因为参数的个数一致，只是y对象多了一个属性）。 只有目标类型（这里是Named）的成员会被一一检查是否兼容。这个比较过程是递归进行的，检查每个成员及子成员。

#### 2.比较两个函数

```typescript
let x = (a: number) => 0;
let y = (b: number, s: string) => 0;

y = x; // OK
x = y; // Error

```

***要查看x是否能赋值给y，首先看它们的参数列表。 x的每个参数必须能在y里找到对应类型的参数。 这里要注意，参数的名字相同与否无所谓，只看它们的类型即可。*** 这里，x的每个参数在y中都能找到对应的参数，所以允许赋值。

第二个赋值错误，因为y有个必需的第二个参数，但是x并没有，所以不允许赋值。

下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数：

```typescript
let x = () => ({name: 'Alice'});
let y = () => ({name: 'Alice', location: 'Seattle'});

x = y; // OK
y = x; // Error

```

在这里，类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。所以y可以赋值给x

# 八、高级类型

#### 1.交叉类型

***下面这个例子，Cat & Dog 同时是 Cat 和 Dog 两个类型的集合***

```typescript
// 这里会把参数的属性全赋值给result
function extend<T, U>(first: T, second: U): T & U {
    let result = <T & U>{};
    for (let id in first) {
        (<any>result)[id] = (<any>first)[id];
    }
    for (let id in second) {
        if (!result.hasOwnProperty(id)) { // 判断result自身是否包含id属性
            (<any>result)[id] = (<any>second)[id];
        }
    }
    return result;
}

var jim = extend(new Cat(), new Dog());


```

函数extend会把传入的参数中的属性全部赋值给result并输出,这里ressult的类型是两个参数的类型的集合

#### 2.联合类型

***联合类型表示一个值可以是几种类型之一。 我们用竖线（ |）分隔每个类型，所以 number | string 表示一个值可以是 number或string，传入的参数只要满足其中之一就行了。***

```typescript
function padLeft(value: string, padding: string | number ) {
    // ...
}


```

***如果一个值是联合类型，那么我们只能访问此联合类型的所有类型里共有的成员。（因为万一访问的那个属性不存在此类型中就会报错，所以最好访问共有属性）***

```typescript
interface Bird {
    fly();
    layEggs();
}

interface Fish {
    swim();
    layEggs();
}

function getSmallPet(): Fish | Bird {
    // ...
}

let pet = getSmallPet();
pet.layEggs(); // okay
pet.swim();    // errors

```

这个例子里， Bird具有一个 fly成员。 我们不能确定一个 Bird | Fish类型的变量是否有 fly方法。 如果变量在运行时是 Fish类型，那么调用 pet.fly()就出错了。

#### 3.类型保护与区分类型

***如何区分到底是哪种类型呢？***   可以使用类型断言

下面这个例子使用了类型断言，就避免了报错

```typescript
let pet = getSmallPet();

if ((<Fish>pet).swim) {
    (<Fish>pet).swim();
}
else {
    (<Bird>pet).fly();
}

```

***用户自定义的类型保护*** 如果多次使用类型断言，那么会很麻烦，我们可以封装一个函数，通过函数来判断到底是哪个类型

```typescript
function isFish(pet: Fish | Bird): pet is Fish {
    return (<Fish>pet).swim !== undefined;
}
// 'swim' 和 'fly' 调用都没有问题了
if (isFish(pet)) {
    pet.swim();
}
else {
    pet.fly();
}

```

pet is Fish是类型谓词。 谓词为 propsName is Type这种形式， propsName必须是来自于当前函数里的一个参数名。

#### 4.typeof或instanceof类型保护（注意typeof（基本数据类型）和instanceof（引用数据类型）的使用范围）

```typescript
function padLeft(value: string, padding: string | number) {
    if (typeof padding === "number") {
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}

```

使用typeof或instanceof在使用参数前判断类型，也可以避免报错

# 九、声明合并

#### 1.合并接口

合并的机制是把双方的成员放到一个同名的接口里。

```typescript
interface Box {
    height: number;
    width: number;
}
interface Box {
    scale: number;
}
let box: Box = {height: 5, width: 6, scale: 10};

```

两种成员类型：

***非函数成员***

- 接口的非函数的成员应该是唯一的。
- 如果它们不是唯一的，那么它们必须是相同的类型。
- 如果非函数成员同名但是它们的类型不同，则编译器会报错。

***函数成员***

- 每个同名函数声明都会被当成这个函数的一个重载(函数重载是指在同一作用域内，可以有一组具有相同函数名，不同参数列表的函数)
- 当接口 A与后来的接口 A合并时，后面的接口具有更高的优先级。

如下面的例子

```typescript
interface Cloner {
    clone(animal: Animal): Animal;
}
interface Cloner {
    clone(animal: Sheep): Sheep;
}
interface Cloner {
    clone(animal: Dog): Dog;
    clone(animal: Cat): Cat;
}

```

这三个接口合并成一个声明：

```typescript
interface Cloner {
    clone(animal: Dog): Dog;
    clone(animal: Cat): Cat;
    clone(animal: Sheep): Sheep;
    clone(animal: Animal): Animal;
}

```

调用clone这个函数的时候，会优先使用第一个声明

***这个规则有一个例外是当出现特殊的函数签名时。 如果签名里有一个参数的类型是单一的字符串字面量,那么它将会被提升到重载列表的最顶端。***

比如，下面的接口会合并到一起：

```typescript
interface Document {
    createElement(tagName: any): Element;
}
interface Document {
    createElement(tagName: "div"): HTMLDivElement;
    createElement(tagName: "span"): HTMLSpanElement;
}
interface Document {
    createElement(tagName: string): HTMLElement;
    createElement(tagName: "canvas"): HTMLCanvasElement;
}

```

合并后的 Document将会像下面这样：

```typescript
interface Document {
    createElement(tagName: "canvas"): HTMLCanvasElement;
    createElement(tagName: "div"): HTMLDivElement;
    createElement(tagName: "span"): HTMLSpanElement;
    createElement(tagName: string): HTMLElement;
    createElement(tagName: any): Element;
}

```

这个合并会把字符串字面量的参数放在最前面，把其他参数放在后面。

